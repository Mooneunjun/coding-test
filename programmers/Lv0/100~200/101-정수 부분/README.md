> [정수 부분](https://school.programmers.co.kr/learn/courses/30/lessons/181850)

## **문제 설명**

실수 `flo`가 매개 변수로 주어질 때, `flo`의 정수 부분을 return하도록 solution 함수를 완성해주세요.

---

### 제한사항

- 0 ≤ `flo` ≤ 100

---

### 입출력 예

| flo   | result |
| ----- | ------ |
| 1.42  | 1      |
| 69.32 | 69     |

---

### 입출력 예 설명

입출력 예 #1

- 1.42의 정수 부분은 1입니다.

입출력 예 #2

- 69.32의 정수 부분은 69입니다.

---

## 코드

```jsx
function solution(flo) {
  return parseInt(flo);
}
```

---

### **설명**

- `Math.floor()` 함수는 **주어진 실수의 소수점 이하를 버리고 가장 가까운 정수(작거나 같은 정수)** 를 반환합니다.
  - 예: `Math.floor(1.42)` → 1
  - 예: `Math.floor(69.32)` → 69

### **다른 방법들 (참고용)**

```jsx
// 1. 비트 연산자 (소수점 이하 제거)
function solution(flo) {
  return flo | 0;
}

// 2. parseInt 사용
function solution(flo) {
  return parseInt(flo);
}
```

하지만 위 두 방법은 **양수에서는 문제 없지만**, **음수가 들어올 수 있는 일반적인 경우**에는 `Math.floor()`가 더 정확하고 안전합니다.

현재 문제의 제한사항에선 `flo >= 0`이기 때문에 모두 사용 가능하지만, 가장 명확한 방법은 `Math.floor()`입니다.

---

### **`Math.floor()` vs `parseInt()` vs `비트 연산 (| 0)`**

```jsx
const num = -1.9;
```

### **1. `Math.floor(num)`**

```jsx
Math.floor(-1.9); // ➜ -2
```

- **설명**: 소수점을 버리고, **더 작은 쪽 정수로 내림** (즉, -1.9 → -2)

### **2. `parseInt(num)`**

```
parseInt(-1.9); // ➜ -1
```

- **설명**: 문자열로 변환된 수에서 소수점 앞까지만 해석 → 실제로는 **문자열 파싱 동작**
- ⚠️ **정확한 내림이 아님** — 예상과 다르게 작동할 수 있음

### **3. `num | 0` (비트 연산)**

```
-1.9 | 0; // ➜ -1
```

- **설명**: 비트 연산자 사용 시 소수점 이하 버림 **(정수로 강제 변환)**
- 그러나 결과는 **0 쪽으로 내림** ⇒ -1.9 → -1

### **결론: `Math.floor()` 가 더 정확하고 안전한 이유**

- Math.floor()는 **항상 “작거나 같은 정수”로 내림**하여 수학적으로 가장 정확한 **내림 함수**입니다.
- 반면, parseInt()나 | 0은 양수에는 같게 동작하지만, **음수에서는 “0 방향”으로 내림**하여 예기치 않은 결과를 줄 수 있습니다.

---

## **👇 정리**

| **함수**   | -1.9 **결과** | **설명**                    |
| ---------- | ------------- | --------------------------- |
| Math.floor | -2            | 작거나 같은 정수로 내림     |
| parseInt   | -1            | 문자열 파싱으로 소수점 제거 |
| `          | 0`            | -1                          |

---

**따라서, 일반적인 환경에서 정수 부분을 안전하게 구하고 싶다면 Math.floor()를 사용하는 것이 가장 신뢰할 수 있는 방법입니다.**

---

### **정수로 변환하고 싶다면? — 방법별 차이 정리**

| **목적 / 특징**                     | **사용법**         | **예시 (1.42)** | **예시 (-1.42)** | **비고**                                  |
| ----------------------------------- | ------------------ | --------------- | ---------------- | ----------------------------------------- |
| 소수점 이하 **버림 (내림)**         | Math.floor()       | 1               | **-2**           | 가장 정확한 내림(항상 더 작은 정수로)     |
| 소수점 이하 **올림**                | Math.ceil()        | 2               | **-1**           | 항상 더 큰 정수로                         |
| 가장 **가까운 정수**                | Math.round()       | 1               | **-1**           | .5 이상 올림                              |
| 정수 부분만 가져오기 (0쪽으로 절삭) | Math.trunc()       | 1               | **-1**           | ES6+, 직관적이고 안전                     |
| 정수 부분만 가져오기 (0쪽으로 절삭) | parseInt(숫자)     | 1               | **-1**           | 문자열 파싱이므로 숫자 변환 용도는 추천 X |
| 문자열에서 숫자만 파싱              | parseInt("문자열") | "1.42" → 1      | "-1.42" → -1     | 소수점 이후는 무시                        |
| 소수점 이하 제거 (0쪽으로 절삭)     | ~~숫자             | 1               | **-1**           | 빠르지만 32비트 정수 제한 / 가독성 ↓      |

---

### **🔍 어떤 상황에서 어떤 방법을 쓰면 좋을까?**

| **상황**                                      | **추천 방법**      | **이유**                          |
| --------------------------------------------- | ------------------ | --------------------------------- |
| 음수 포함 & 정확한 내림이 필요                | Math.floor()       | 가장 신뢰할 수 있는 내림 함수     |
| 소수점 절삭이 목적이며 음/양수 둘 다 취급     | Math.trunc()       | 의도 표현이 명확하고 안전         |
| 단순 반올림                                   | Math.round()       | 일반적인 반올림                   |
| 빠른 정수 절삭이 필요 & 값이 32비트 정수 범위 | ~~num              | 고성능 트릭이지만 협업에는 비추천 |
| 문자열에서 정수만 뽑아야 할 때                | parseInt("문자열") | 숫자+문자 혼합 문자열 파싱에 적합 |

---

### **한 줄 요약**

> 숫자의 정수 부분을 가장 안전하게 얻고 싶다면 Math.trunc()(절삭) 또는 Math.floor()(내림)가 가장 권장된다. (parseInt()와 ~~는 특정 상황을 제외하면 비추천)
