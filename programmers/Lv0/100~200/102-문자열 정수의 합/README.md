> [문자열 정수의 합](https://school.programmers.co.kr/learn/courses/30/lessons/181849)

### **문제 설명**

한 자리 정수로 이루어진 문자열 `num_str`이 주어질 때, 각 자리수의 합을 return하도록 solution 함수를 완성해주세요.

---

### 제한사항

- 3 ≤ `num_str` ≤ 100

---

### 입출력 예

| num_str     | result |
| ----------- | ------ |
| "123456789" | 45     |
| "1000000"   | 1      |

---

### 입출력 예 설명

입출력 예 #1

- 문자열 안의 모든 숫자를 더하면 45가 됩니다.

입출력 예 #2

- 문자열 안의 모든 숫자를 더하면 1이 됩니다.

---

## 코드

```jsx
function solution(num_str) {
  return num_str.split("").reduce((acc, curr) => acc + Number(curr), 0);
}

console.log(solution("123456789")); // 45
console.log(solution("1000000")); // 1
```

---

## 코드 설명

`num_str`을 `split("")`을 사용해 한 글자씩 분리한 배열로 변환한 뒤,

`reduce()`를 활용하여 각 요소를 `Number()`로 형변환하면서 누적해 합을 계산하는 방식입니다.

핵심 흐름

`"1234"` → `["1", "2", "3", "4"]` → `1 + 2 + 3 + 4 = 10`

사용된 주요 메서드

| 코드        | 역할                                |
| ----------- | ----------------------------------- |
| `split("")` | 문자열을 한 글자씩 배열로 변환      |
| `reduce()`  | 배열 요소를 순회하며 누적 계산 수행 |
| `Number()`  | 문자형 숫자를 숫자로 변환           |

---

## 다른 풀이 방법

### 1) `for-of` 반복문 사용

```jsx
function solution(num_str) {
  let sum = 0;
  for (let n of num_str) sum += Number(n);
  return sum;
}
```

### 2) 전개 연산자 + `reduce()`

```jsx
const solution = (num_str) => [...num_str].reduce((a, c) => a + +c, 0);
```

### 3) `Array.from()` 활용

```jsx
function solution(num_str) {
  return Array.from(num_str, Number).reduce((a, c) => a + c, 0);
}
```

---

## 추가 내용

### 1. `split("")` 의 장점

문자열을 전개하는 방식은 여러 가지가 있습니다.

| 방식                  | 결과                | 시간/메모리 복잡도 | 비고                                   |
| --------------------- | ------------------- | ------------------ | -------------------------------------- |
| `split("")`           | 새 배열 생성        | O(n)               | 문자열 → 배열 명시적 변환              |
| `[...num_str]`        | 새 배열 생성        | O(n)               | 내부적으로 spread 연산은 iterator 기반 |
| `Array.from(num_str)` | 새 배열 생성        | O(n)               | mapping 콜백 활용 가능                 |
| `for-of` 반복         | 배열 생성 없이 순회 | O(n)               | 가장 메모리 효율적                     |

즉, **split은 구현은 간단하지만 메모리 할당이 추가**됩니다.

> 문자열이 매우 길거나 메모리 최적화가 중요하다면
>
> `for-of` 방식이 더 효율적입니다.

---

### 2. `reduce()`를 사용하는 이유

| 비교          | `for` 반복문  | `reduce()`                    |
| ------------- | ------------- | ----------------------------- |
| 구현          | 장황해짐      | 한 줄에 표현 가능             |
| 선언형/가독성 | 로직이 명령형 | **합을 구한다는 목적이 명확** |
| 부작용 위험   | 변수 노출     | 내부 스코프에서 안전하게 처리 |

즉, reduce는 **의도를 드러내는 함수형 코드**입니다.

> 합을 구하는 상황에서 reduce는 정답에 가깝다.

---

### 3. `Number(curr)` vs `parseInt(curr)` vs `+curr`

| 방식             | 장점      | 단점                     |
| ---------------- | --------- | ------------------------ |
| `Number(curr)`   | 타입 명확 | 다소 길다                |
| `parseInt(curr)` | 유연함    | 문자 포함 시 오해 가능   |
| `+curr`          | 가장 짧음 | 초보자에게 가독성 떨어짐 |

예시:

```jsx
parseInt("08px"); // 8 ← 좋은 결과인가?
Number("08px"); // NaN ← 에러를 명확히 드러냄
```

> 에러를 감추지 않는 것이 더 안전

그래서 `Number()` 선택도 충분한 이유가 존재합니다.

---

## 다른 풀이와 문제점 비교

### for-of 방식 (메모리 효율 최고)

```jsx
function solution(num_str) {
  let sum = 0;
  for (const c of num_str) sum += Number(c);
  return sum;
}
```

- 장점: 불필요한 중간 배열 생성 없음
- 단점: 함수형 의도가 약해짐

---

### reduce + spread 방식

```jsx
[...num_str].reduce(...)

```

- 가독성 좋음
- 하지만 **문자열 Iterator → 배열 복사 추가 비용**

---

### Array.from 방식

```jsx
Array.from(num_str, Number);
```

- 문자 → 숫자 mapping이 한 번에 처리됨
- 하지만 Array.from 자체가 오버헤드가 있음

---

## 어떤 방식이 “좋은가”?

| 목적 기준                        | 추천 풀이              |
| -------------------------------- | ---------------------- |
| 가장 직관적이고 가독성 높은 코드 | `split("") + reduce()` |
| 메모리 효율 우선                 | `for-of`               |
| 함수형으로 끝까지 가고 싶을 때   | `Array.from()`         |

즉, 현재 문제의 스케일에서는 **가독성과 의도 투명성이 우선 → reduce 기반 풀이가 최선**

---

## 확장 상황을 생각해보자

| 확장 사례               | 추가로 고려해야 할 문제   |
| ----------------------- | ------------------------- |
| 문자열 길이 수천~수백만 | GC 부담, 메모리 효율 고려 |
| 음수 포함               | 입력 검증 로직 필요       |
| 숫자가 아닌 문자 포함   | 예외 처리 필수            |
| BigInt 범위             | 기본 정수 연산 불가 →     |

예: 1000자리 초과 숫자 → `bigint` 또는 직접 자리수 연산

---

## 결론

**좋은 코드는 단순하게 보이지만 내부적으로 많은 트레이드오프를 고려한 결과입니다.**

- 왜 reduce인가?
  → "합을 구한다"는 목적과 가장 직결되므로
- 왜 Number인가?
  → 실패 시 오류를 숨기지 않기 때문
- 왜 split인가?
  → 명확하고 직관적인 문자열 처리
