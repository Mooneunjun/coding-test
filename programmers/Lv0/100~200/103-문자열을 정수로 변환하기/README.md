> [문자열을 정수로 변환하기](https://school.programmers.co.kr/learn/courses/30/lessons/181848)

### **문제 설명**

숫자로만 이루어진 문자열 `n_str`이 주어질 때, `n_str`을 정수로 변환하여 return하도록 solution 함수를 완성해주세요.

---

### 제한사항

- 1 ≤ `n_str` ≤ 5
- `n_str`은 0부터 9까지의 정수 문자로만 이루어져 있습니다.

---

### 입출력 예

| n_str  | result |
| ------ | ------ |
| "10"   | 10     |
| "8542" | 8542   |

---

### 입출력 예 설명

입출력 예 #1

- "10"을 정수로 바꾸면 10입니다.

입출력 예 #2

- "8542"를 정수로 바꾸면 8542입니다.

---

## 1. 문제 핵심 정리

- 입력: `"8542"`처럼 **숫자로만 이루어진 문자열**
- 출력: **정수 타입**
- 제약이 작기 때문에 성능은 모든 방식이 충분하다.
- 하지만 JavaScript의 특성상 “문자열을 숫자로 바꾸는 다양한 방식”의 차이를 이해하는 것이 학습의 핵심이다.

---

## 2. 권장 풀이 — `Number()` 사용

```jsx
function solution(n_str) {
  return Number(n_str);
}
```

### 왜 `Number()`인가?

- 명시적 타입 변환(explicit coercion) 함수이며, **가장 의도가 명확한 방식**이다.
- JavaScript 엔진이 문자열을 정수/실수 모두 포함한 숫자로 정확하게 변환해준다.
- `"0012"`와 같이 앞자리 0이 포함되어도 정상 동작한다.
- `"10e2"`(지수 표기), `" 42 "`(공백 포함)도 올바르게 처리가능하지만, 이번 문제에서는 입력 범위가 좁아 영향을 주지 않는다.

> 실무 기준
>
> API 파라미터, 환경 변수(`process.env.*`), 쿼리 스트링 파싱 등에서 가장 일반적으로 사용되는 방법이다.
>
> 명확한 의도 표출 + 예측 가능한 동작 = 협업 환경에서 가장 안전하다.

---

## 3. 대안적 풀이 (상황에 따라 유용)

### 3.1 `parseInt`

```jsx
function solution(n_str) {
  return parseInt(n_str, 10);
}
```

### 특징

- 문자열을 정수로 변환.
- 두 번째 인자로 `10`을 명시하면 예상치 못한 진법 문제를 예방할 수 있다.
- 숫자가 아닌 문자를 만나면 변환을 중단한다. (`"10px"` → `10`)

### 이 문제에서는 왜 굳이 사용할 필요가 없는가?

- 입력값이 오로지 숫자로만 이루어져 있어 **`Number()`와 차이가 없다**.
- 하지만 `parseInt`는 "정수 변환"이라는 의미가 강해 실수를 허용하지 않는다.

---

### 3.2 단항 연산자 `+`

```jsx
function solution(n_str) {
  return +n_str;
}
```

### 장점

- 매우 짧고 빠르다.
- 암묵적 타입 변환을 수행한다.

### 단점

- **의도가 즉시 드러나지 않는다.**
  특히 JS 초중급 개발자에게는 가독성이 좋지 않다.
- `" "`(공백), `" 42 "` 등의 값 처리 시 동작이 명확히 보이지 않는다.

> 실무에서는 팀 규칙에 따라 사용 여부가 달라진다.
>
> 퍼포먼스가 중요한 로우 레벨 로직에서는 사용되지만, 일반적인 웹백엔드/프론트 코드에서는 잘 쓰지 않는다.

---

## 4. 비추천 풀이

### 4.1 `parseFloat` 사용

입력이 정수 문자열이라는 점에서 불필요하다.

### 4.2 `~~n_str` (비트 연산자 활용)

- 빠르긴 하지만 32비트 정수 범위 제한, 부호 처리 등 부작용이 많다.
- **문제에서 요구하는 범위에서는 동작하지만** 확장성·가독성 측면에서 배제해야 한다.

---

## 5. 전체 비교

| 방식              | 의도 명확성 | 확장성     | 가독성     | 비고                             |
| ----------------- | ----------- | ---------- | ---------- | -------------------------------- |
| `Number()`        | ⭐⭐⭐⭐⭐  | ⭐⭐⭐⭐⭐ | ⭐⭐⭐⭐⭐ | 가장 권장되는 방식               |
| `parseInt(n, 10)` | ⭐⭐⭐⭐    | ⭐⭐⭐⭐   | ⭐⭐⭐⭐   | 정수-only 상황에서 유용          |
| `+n`              | ⭐⭐⭐      | ⭐⭐⭐     | ⭐⭐       | 아주 짧지만 의도가 모호함        |
| `~~n`             | ⭐          | ⭐         | ⭐         | 비트 연산 기반 트릭, 실무 비추천 |

---

## 6. 예외 케이스 관점 (문제를 확장한다면)

이번 문제는 숫자만 주어지지만, 실제 서비스에서는 다음 케이스도 고려해야 한다.

1. `"0012"` → 앞자리 0
2. `" 42 "` → 공백 포함 입력
3. `"10px"` → 숫자 뒤 문자열 포함
4. `""` → 빈 문자열
5. `"1e3"` → 지수 표기
6. `"Infinity"` → 무한대
7. `"0000000000000000000001"` → 매우 긴 숫자 (BigInt 고려)

입력 정제와 숫자 변환 정책이 리스크를 줄이는 핵심이다.

---

## 7. 결론 및 학습 포인트

- 이 문제는 단순하지만, **JavaScript의 타입 변환 전략을 이해하는 좋은 출발점**이다.
- 실무에서는 **명시적 타입 변환**을 사용하여 코드 의도를 분명히 하는 것이 중요하다.
- 특히 API 개발 시, 숫자·문자열 변환 정책을 일관되게 관리해야 협업 생산성이 올라간다.

**최종 권장 코드:**

```jsx
function solution(n_str) {
  return Number(n_str);
}
```
