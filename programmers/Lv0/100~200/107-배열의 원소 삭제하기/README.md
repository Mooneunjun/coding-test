> [배열의 원소 삭제하기](https://school.programmers.co.kr/learn/courses/30/lessons/181844)

### **문제 설명**

정수 배열 `arr`과 `delete_list`가 있습니다. `arr`의 원소 중 `delete_list`의 원소를 모두 삭제하고 남은 원소들은 기존의 `arr`에 있던 순서를 유지한 배열을 return 하는 solution 함수를 작성해 주세요.

---

### 제한사항

- 1 ≤ `arr`의 길이 ≤ 100
- 1 ≤ `arr`의 원소 ≤ 1,000
- `arr`의 원소는 모두 서로 다릅니다.
- 1 ≤ `delete_list`의 길이 ≤ 100
- 1 ≤ `delete_list`의 원소 ≤ 1,000
- `delete_list`의 원소는 모두 서로 다릅니다.

---

### 입출력 예

| arr                       | delete_list                 | result                 |
| ------------------------- | --------------------------- | ---------------------- |
| [293, 1000, 395, 678, 94] | [94, 777, 104, 1000, 1, 12] | [293, 395, 678]        |
| [110, 66, 439, 785, 1]    | [377, 823, 119, 43]         | [110, 66, 439, 785, 1] |

---

### 입출력 예 설명

입출력 예 #1

- 예제 1번의 `arr`의 원소 중 1000과 94가 `delete_list`에 있으므로 이 두 원소를 삭제한 [293, 395, 678]을 return 합니다.

입출력 예 #2

- 예제 2번의 `arr`의 원소 중 `delete_list`에 있는 원소는 없습니다. 따라서 `arr` 그대로인 [110, 66, 439, 785, 1]을 return 합니다.

---

알겠습니다. 아래는 이모티콘 없이, 기술 블로그 문체에 맞춰 **중후하고 절제된 톤**으로 다시 작성한 후반부입니다.

문제 설명 아래에 그대로 이어 붙일 수 있도록 구성했습니다.

---

## 접근 방법

이 문제는 `arr` 내부의 원소 중 `delete_list`에 포함된 값을 제거하고, 나머지는 기존 순서를 유지한 채 반환하는 단순한 필터링 문제다. 핵심은 두 가지로 요약된다.

1. 현재 값이 삭제 대상인지 빠르게 판별해야 한다.
2. 삭제 대상이 아니라면 결과 배열에 포함해야 한다.

이를 JavaScript에서 구현할 때 가장 적합한 도구는 `Set`과 `Array.prototype.filter`이다. 두 개념을 명확히 이해하면 코드가 왜 이러한 구조를 취하는지 자연스럽게 파악된다.

---

## Set의 필요성과 동작 원리

`Set`은 중복을 허용하지 않는 데이터 집합을 저장하는 자료구조로, 특정 값이 포함되어 있는지 판별하는 연산이 평균적으로 O(1)의 시간에 수행된다. 배열에서 동일한 작업을 할 경우 `includes`를 사용해야 하고, 이는 매번 O(n) 탐색이 필요하므로 전체 성능이 저하된다.

이 문제에서는 삭제해야 할 값들을 `Set`에 담아두고 `has` 메서드로 빠르게 포함 여부를 확인하는 전략이 가장 적합하다.

```jsx
const toDelete = new Set(delete_list);
```

위 코드는 삭제 대상 목록을 `Set`으로 변환한다. 이후 `toDelete.has(value)`는 `value`가 삭제 대상에 포함되면 `true`, 포함되지 않으면 `false`를 반환한다.

---

## filter의 동작 방식

`filter`는 배열을 처음부터 끝까지 순회하며, 콜백 함수가 `true`를 반환할 때만 해당 값을 결과 배열에 포함한다. 원본 배열을 직접 수정하지 않고, 조건을 만족하는 값들만 모아 새로운 배열을 생성한다는 점에서 선언적이고 명료한 방식이다.

형식은 다음과 같다.

```jsx
arr.filter((value) => 조건식);
```

조건식이 `true`일 때 `value`는 유지되고, `false`일 때는 제거된다.

이 문제에서의 조건은 단순하다.

> "삭제 대상에 포함되어 있지 않은 값만 남긴다."

따라서 조건식은 `!toDelete.has(value)`가 된다.

---

## 최종 코드

```jsx
function solution(arr, delete_list) {
  const toDelete = new Set(delete_list);
  return arr.filter((value) => !toDelete.has(value));
}
```

---

## 코드 동작 과정

예제 1을 기준으로 실제 동작을 표로 정리하면 다음과 같다.

`arr = [293, 1000, 395, 678, 94]`

`toDelete = new Set([94, 777, 104, 1000, 1, 12])`

| 값   | toDelete.has(value) | 유지 여부 |
| ---- | ------------------- | --------- |
| 293  | false               | 유지      |
| 1000 | true                | 제거      |
| 395  | false               | 유지      |
| 678  | false               | 유지      |
| 94   | true                | 제거      |

결과는 `[293, 395, 678]`이 된다.

---

## 다른 구현 방식과의 비교

### 1. 배열 `includes` 사용

```jsx
arr.filter((value) => !delete_list.includes(value));
```

문제의 입력 규모에서는 정상적으로 동작하지만, 삭제 대상 목록이 커지면 반복적으로 전체 배열을 탐색해야 하므로 효율성이 떨어진다.

### 2. Set 기반 구현

```jsx
const toDelete = new Set(delete_list);
arr.filter((value) => !toDelete.has(value));
```

삭제 대상 여부를 확인하는 연산이 상수 시간에 이루어지므로 더 안정적이며, 특히 입력 크기가 커지는 환경에서는 필수에 가깝다.

---

## 정리

- `Set`은 삭제 대상 목록을 빠르게 조회하기 위한 최적의 자료구조다.
- `filter`는 조건 기반 요소 추출에 적합한 선언적 API다.
- 이 두 가지를 조합하면 가독성, 성능, 확장성 모두 균형 잡힌 구조를 만들 수 있다.
- 실무에서도 유지 조건 또는 필터링 조건이 있는 배열 처리에서는 동일한 패턴이 자주 사용된다.

필요하다면 이어서 시간 복잡도 분석, 확장 문제 제안, 또는 다른 언어(Java, Python 등) 버전의 비교도 작성할 수 있다.
