> [5명씩](https://school.programmers.co.kr/learn/courses/30/lessons/181886)

### **문제 설명**

최대 5명씩 탑승가능한 놀이기구를 타기 위해 줄을 서있는 사람들의 이름이 담긴 문자열 리스트 `names`가 주어질 때, 앞에서 부터 5명씩 묶은 그룹의 가장 앞에 서있는 사람들의 이름을 담은 리스트를 return하도록 solution 함수를 완성해주세요. 마지막 그룹이 5명이 되지 않더라도 가장 앞에 있는 사람의 이름을 포함합니다.

---

### 제한사항

- 5 ≤ `names`의 길이 ≤ 30
- 1 ≤ `names`의 원소의 길이 ≤ 10
- `names`의 원소는 영어 알파벳 소문자로만 이루어져 있습니다.

---

### 입출력 예

| names                                                      | result          |
| ---------------------------------------------------------- | --------------- |
| ["nami", "ahri", "jayce", "garen", "ivern", "vex", "jinx"] | ["nami", "vex"] |

---

### 입출력 예 설명

입출력 예 #1

- 앞에서부터 5명씩 두 그룹으로 묶을 수 있습니다. ["nami", "ahri", "jayce", "garen", "ivern"], ["vex", "jinx"] 이 두 그룹에서 가장 앞에 서있는 사람들의 이름을 담은 리스트인 ["nami", "vex"]를 return합니다.

---

### 첫번째 방법

```jsx
function solution(names) {
  return names.filter((_, i) => i % 5 === 0);
}
```

---

### 코드설명

1. **입력 데이터**:
   - `names`는 문자열 리스트로, 각 원소는 줄을 서 있는 사람들의 이름을 나타냅니다.
2. **그룹의 첫 번째 사람 선택**:
   - `filter` 메서드를 사용하여 조건에 맞는 원소만 남깁니다.
   - `filter`의 콜백 함수는 두 개의 매개변수를 받습니다:
     - `_`: 현재 순회 중인 원소의 값 (이 문제에서는 사용하지 않으므로 `_`로 처리).
     - `i`: 현재 순회 중인 원소의 인덱스.
3. **조건 설정**:
   - `i % 5 === 0`:
     - 인덱스를 5로 나눈 나머지가 0인 경우, 해당 원소는 그룹의 첫 번째 사람입니다.
     - 이는 리스트를 5명씩 묶었을 때 각 그룹의 첫 번째 사람에 해당합니다.
4. **결과 반환**:
   - `filter`를 통해 각 그룹의 첫 번째 사람만 포함된 새로운 리스트를 반환합니다.

---

### 2번째 방법

```jsx
function solution(names) {
  let result = []; // 각 그룹의 첫 번째 사람의 이름을 저장할 배열

  // 5명씩 건너뛰며 그룹의 첫 번째 사람을 선택
  for (let i = 0; i < names.length; i += 5) {
    result.push(names[i]);
  }

  return result; // 결과 반환
}
```

---

### 코드설명

1. **결과 배열 선언**:
   - `result`는 각 그룹의 첫 번째 사람의 이름을 저장할 빈 배열입니다.
2. **`for`문 순회**:
   - `for`문을 사용해 `i`를 `0`부터 시작하며, `i`를 `5`씩 증가시킵니다.
   - 이는 리스트를 5명씩 묶었을 때, 각 그룹의 첫 번째 사람의 인덱스(`0`, `5`, `10` 등)에 해당합니다.
3. **첫 번째 사람 추가**:
   - `names[i]`를 `result` 배열에 추가합니다. 이때 `i`는 현재 그룹의 첫 번째 사람의 인덱스를 나타냅니다.
4. **결과 반환**:
   - 최종적으로 각 그룹의 첫 번째 사람의 이름이 담긴 배열 `result`를 반환합니다.
